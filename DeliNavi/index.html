<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>DeliNavi</title>

  <!-- 軽量favicon（ファイル不要） -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E🗺️%3C/text%3E%3C/svg%3E">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- 回転マーカー -->
  <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <!-- CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- QR生成 -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>

  <style>
    html,body{height:100%;margin:0}
    body{background:#000;overscroll-behavior:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",Meiryo,sans-serif}
    #map{position:fixed;inset:0}

    /* 右上の操作パネル */
    .panel{
      position:absolute;z-index:1000;left:10px;top:10px;background:#fff;
      padding:10px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.15)
    }
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:6px}
    .btn{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f6f6f6;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .badge{background:#111;color:#fff;border-radius:10px;padding:3px 8px;font-weight:700}
    .small{font-size:12px;color:#666}

    /* ===== 順路カード（画面下） ===== */
    .route-card{
      position:fixed; left:8px; right:8px; bottom:8px; z-index:9500;
      background:rgba(0,0,0,.82); color:#fff; border-radius:14px;
      padding:10px 12px; box-shadow:0 10px 24px rgba(0,0,0,.35);
      display:flex; align-items:center; gap:10px; backdrop-filter:saturate(1.2) blur(2px);
    }
    .route-card .meta{flex:1 1 auto; min-width:0}
    .route-card .title{font-weight:800; font-size:20px; line-height:1.2; letter-spacing:.06em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .route-card .addr{opacity:.95; font-size:13px; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .route-card .note{opacity:.85; font-size:12px; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top:2px}
    .route-card .menu-btn{flex:0 0 auto; padding:8px 12px; border-radius:9px; border:1px solid rgba(255,255,255,.25); background:#07445f; color:#fff; font-weight:700; cursor:pointer}

    /* HUD中はカード非表示 */
    body.hud .route-card{ display:none }

    /* 地図上の矢印オーバレイ */
    .turn-overlay{ position:fixed; inset:0; z-index:9400; pointer-events:none; display:none }
    .turn-overlay.show{ display:block }
    .turn-overlay canvas{ position:absolute; left:50%; top:50%; transform:translate(-50%,-60%); width:min(64vw,64vh); height:auto }

    /* Leafletの番号ツールチップを常に非表示（番号バッジ非表示） */
    .leaflet-tooltip{ display:none !important }

    /* HUD上下反転オプション */
    #dn-hud-cv { transition: transform .15s ease; }
    body.hud-flip #dn-hud-cv { transform: rotate(180deg); }
  </style>
</head>
<body>
  <!-- 地図 -->
  <div id="map" aria-label="map"></div>

  <!-- 地図上の矢印オーバレイ -->
  <div id="turnOverlay" class="turn-overlay" aria-hidden="true">
    <canvas id="turnOverlayCv" width="512" height="512"></canvas>
  </div>

  <!-- 順路カード（氏名・住所・備考＋Menu） -->
  <div id="routeCard" class="route-card" role="region" aria-label="次の配達先">
    <div class="meta">
      <div id="rcAddr"  class="addr">—</div>
      <div id="rcTitle" class="title">—</div>
      <div id="rcNote"  class="note">—</div>
    </div>
    <button id="rcMenu" class="menu-btn">Menu</button>
  </div>

  <!-- 右上の操作パネル -->
  <div class="panel">
    <div class="row">
      <span class="badge" id="counter">#0 / 0</span>
      <button class="btn" id="btnFit">全体表示</button>
      <button class="btn" id="btnPrev" disabled>◀ 前</button>
      <button class="btn" id="btnNext" disabled>次 ▶</button>
      <button class="btn" id="btnQR">QR共有</button>
    </div>
    <div class="row">
      <button class="btn" id="btnGPS">GPS開始</button>
      <button class="btn" id="btnStop" disabled>停止</button>
      <label class="small">到着半径 <input type="number" id="radius" value="50" style="width:4.5em"> m</label>
    </div>
    <div class="row">
      <label class="small"><input type="checkbox" id="chkFollow" checked> 中央固定（追従）</label>
      <label class="small"><input type="checkbox" id="chkHeading" checked> 矢印＝進行方向</label>
    </div>
    <div class="small" id="status">初期化中…</div>
  </div>

  <!-- QRモーダル -->
  <div id="qrModal" style="display:none;position:fixed;inset:0;z-index:2000;background:rgba(0,0,0,.5);align-items:center;justify-content:center">
    <div style="background:#fff;padding:16px 18px;border-radius:12px;text-align:center">
      <canvas id="qrCanvas" width="260" height="260"></canvas><br>
      <div style="margin-top:8px;font-size:12px" id="qrUrl"></div>
      <button class="btn" id="qrClose" style="margin-top:10px">閉じる</button>
    </div>
  </div>

  <!-- アプリ本体（JSのみ） -->
  <script>
  (function whenReady(fn){
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, {once:true});
    else fn();
  })
  (function initApp(){

    // ====== 設定 ======
    const CSV_URL = './assets/data/points.csv'; // 列: name,address,note,lat,lng（日本語列名も対応）
    const OFFICIAL_ROUTE_URL = './assets/routes/official-route.geojson';
    const SHOW_PLANNED_LINE = false; // 予定線ON/OFF
    const MIN_RADIUS = 8;           // 到着半径の下限
    const ARRIVE_DWELL_MS = 2000;   // 到着判定の滞在時間
    const SPEED_SLOW_KMH = 8;       // 低速閾値
    const ARRIVE_COOLDOWN_MS = 10000;
    // ▼ 追加：アプローチ時ズームの設定
    const APPROACH_ZOOM_IN_M   = 90;   // 何m以内でズームインするか
    const APPROACH_ZOOM_LEVEL  = 18;   // ズームイン時の倍率（17〜19あたりが見やすい）
    const APPROACH_ZOOM_OUT_M  = 140;  // 離れたらズームアウト（ヒステリシス用）
    const APPROACH_FLY_MS      = 800;  // アニメーション時間(ms)
    
    // ▼ 追加：自動ズームの状態
    let __autoZoomed = false;
    let __autoZoomPrevZoom = null;
    let __autoZoomTargetIdx = null; // どの目的地を対象にしているか

    // ====== 地図 ======
    const map = L.map('map', {zoomControl:true, preferCanvas:true}).setView([35.0,135.87], 13);
    window.__DN_map = map; // assistモジュール用
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      {maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

    // ズームボタンにアクセシビリティ名
    const zc = map.zoomControl;
    if (zc && zc._zoomInButton) {
      zc._zoomInButton.setAttribute('title','拡大'); zc._zoomInButton.setAttribute('aria-label','拡大');
    }
    if (zc && zc._zoomOutButton) {
      zc._zoomOutButton.setAttribute('title','縮小'); zc._zoomOutButton.setAttribute('aria-label','縮小');
    }

    // ====== 公式ルート表示 ======
    const officialRouteGroup = L.featureGroup().addTo(map);
    let officialSegments = [], officialRouteFlat = [], legHighlight = null;

    // ====== 目的地（CSV） ======
    let csvRows = [];
    let destMarkers = [];
    let plannedLayer = null;

    // ====== 実走ログ ======
    const liveTrack = L.polyline([], {color:'#222', weight:3}).addTo(map);

    // ====== 自位置マーカー ======
    const userIcon = L.icon({
      iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
           <defs><filter id="s"><feDropShadow dx="0" dy="1" stdDeviation="1" flood-opacity="0.4"/></filter></defs>
           <g filter="url(#s)">
             <circle cx="32" cy="32" r="9" fill="#fff"/>
             <polygon points="32,6 44,34 32,28 20,34" fill="#007aff"/>
           </g>
         </svg>`
      ),
      iconSize:[44,44], iconAnchor:[22,22]
    });
    let userMarker = null, userAccCircle = null;
    let followMode = true, rotateToHeading = true;
    let lastLatLng = null, lastHeading = 0;

    // ====== UIヘルパ ======
    const $ = s => document.querySelector(s);
    const setStatus = t => $('#status').textContent = t;

    // --- 自動ズーム制御 ---
      function autoZoomMaybe(distM, hereLatLng){
        // 現在のターゲット（ラベル側のindexを採用）
        const idx = window.DN_destLabelIndex?.();
        if (idx == null) return;
      
        // ターゲットが変わったら状態リセット
        if (__autoZoomTargetIdx !== idx) {
          autoZoomReset(/*restore=*/false);
          __autoZoomTargetIdx = idx;
        }
      
        if (!__autoZoomed && distM <= APPROACH_ZOOM_IN_M) {
          __autoZoomPrevZoom = map.getZoom();
          __autoZoomed = true;
          // 現在位置へ軽く寄せる（追従がONなら中心化されます）
          map.flyTo(hereLatLng, APPROACH_ZOOM_LEVEL, { animate: true, duration: APPROACH_FLY_MS/1000 });
        }
      
        if (__autoZoomed && distM >= APPROACH_ZOOM_OUT_M) {
          // 近くまで寄った後、十分離れたら戻す
          autoZoomRestore();
        }
      }
      
      function autoZoomRestore(){
        if (!__autoZoomed) return;
        const z = (__autoZoomPrevZoom ?? 15);
        __autoZoomed = false;
        __autoZoomPrevZoom = null;
        map.flyTo(map.getCenter(), z, { animate: true, duration: APPROACH_FLY_MS/1000 });
      }
      
      function autoZoomReset(restore=true){
        if (restore) autoZoomRestore();
        __autoZoomed = false;
        __autoZoomPrevZoom = null;
      }

    // ====== イベント配線 ======
    $('#btnFit').addEventListener('click', fitAll);
    $('#btnPrev').addEventListener('click', e=>{ e.preventDefault(); stepCSV(-1); });
    $('#btnNext').addEventListener('click', e=>{ e.preventDefault(); stepCSV(+1); });
    $('#btnGPS').addEventListener('click', startGPS);
    $('#btnStop').addEventListener('click', stopGPS);
    $('#btnQR').addEventListener('click', showQR);
    $('#qrClose').addEventListener('click', ()=>{ $('#qrModal').style.display='flex' === 'x' ? 0 : $('#qrModal').style.display='none'; $('#qrModal').style.display='none'; });
    $('#chkFollow').addEventListener('change', e=>{ followMode=e.target.checked; if(followMode && lastLatLng) map.setView(lastLatLng, map.getZoom(), {animate:false}); });
    $('#chkHeading').addEventListener('change', e=>{ rotateToHeading=e.target.checked; if(userMarker?.setRotationAngle) userMarker.setRotationAngle(rotateToHeading?lastHeading:0); });

    // Menuボタンで操作パネルの表示/非表示
    $('#rcMenu').addEventListener('click', ()=>{
      const p = document.querySelector('.panel'); if(!p) return;
      p.style.display = (p.style.display==='none') ? 'block' : 'none';
    });

    // 起動時にHUD/左右反転オプション復元
    if (localStorage.getItem('dnHudFlip')==='1') document.body.classList.add('hud-flip');
    if (localStorage.getItem('dnTurnInvert')==='1') document.body.classList.add('turn-invert');

    // ====== 初期ロード ======
    Promise.all([loadOfficialRoute(), loadCSV()])
      .then(()=>{ setStatus('準備OK。GPS開始でスタート'); fitAll(); })
      .catch(err=>{ console.error(err); setStatus('読み込みエラー: '+err.message); });

    // ====== CSV 読み込み ======
    async function loadCSV(){
      const res = await fetch(CSV_URL, {cache:'no-store'});
      if(!res.ok) throw new Error('points.csv not found');
      const text = await res.text();
      const parsed = Papa.parse(text, {header:true, skipEmptyLines:true});

      csvRows = parsed.data.map(r=>({
        name: (r.name ?? r.氏名 ?? r.お名前 ?? r.label ?? '').trim(),
        address: (r.address ?? r.住所 ?? r.所在地 ?? '').trim(),
        note: (r.note ?? r.備考 ?? r.メモ ?? r.区分 ?? '').trim(),
        lat: parseFloat(r.lat ?? r.latitude ?? r.緯度),
        lng: parseFloat(r.lng ?? r.longitude ?? r.経度)
      }));

      // マーカー作成（座標がある行のみ）
      destMarkers.forEach(m=>map.removeLayer(m)); destMarkers=[];
      if (plannedLayer){ map.removeLayer(plannedLayer); plannedLayer=null; }

      csvRows.forEach((d,i)=>{
        if (Number.isFinite(d.lat) && Number.isFinite(d.lng)) {
          const m = L.marker([d.lat,d.lng]).addTo(map);
          destMarkers.push(m);
        }
      });

      // assist側へ登録 → 起動直後は「次だけ」
      window.DN_registerDestinationMarkers && window.DN_registerDestinationMarkers(destMarkers, map);
      window.DN_setMarkerMode && window.DN_setMarkerMode('next');

      // 予定線（任意）
      if (SHOW_PLANNED_LINE) {
        const line = csvRows.filter(d=>Number.isFinite(d.lat)&&Number.isFinite(d.lng))
                            .map(d=>[d.lat,d.lng]);
        plannedLayer = L.polyline(line, { color:'#1e6bff', weight:3, dashArray:'6 6' }).addTo(map);
      }

      // 到着半径のUI調整
      const radInput = $('#radius');
      if (radInput){ radInput.min = MIN_RADIUS; radInput.step = 1; if ((parseFloat(radInput.value)||0) < MIN_RADIUS) radInput.value = MIN_RADIUS; }

      // カード初期表示
      setTimeout(()=>{ refreshCounterAndHighlight(); renderRouteCard(); }, 0);
    }

    // ====== 公式ルート（FeatureCollection/MultiLine対応） ======
    async function loadOfficialRoute(){
      const res = await fetch(OFFICIAL_ROUTE_URL + '?v=' + Date.now(), {cache:'no-store'});
      if(!res.ok) throw new Error('official-route.geojson not found');
      const gj = await res.json();

      officialRouteGroup.clearLayers();
      officialSegments = []; officialRouteFlat = [];

      const feats = (gj.type==='FeatureCollection') ? (gj.features||[]) : [gj];
      feats.forEach(ft=>{
        if(!ft?.geometry) return;
        const color = (ft.properties?.leg==='back') ? '#ff8c00' : '#00a7a7';
        const segs = [];
        if(ft.geometry.type==='LineString'){
          if(ft.geometry.coordinates?.length>=2) segs.push(ft.geometry.coordinates);
        }else if(ft.geometry.type==='MultiLineString'){
          (ft.geometry.coordinates||[]).forEach(c=>{ if(c?.length>=2) segs.push(c); });
        }
        segs.forEach(coords=>{
          const latlngs = coords.map(([lng,lat])=>[lat,lng]);
          L.polyline(latlngs, {color, weight:5, opacity:.9}).addTo(officialRouteGroup);
          officialSegments.push(latlngs);
          officialRouteFlat.push(...latlngs);
        });
      });
    }

    // ====== 表示範囲 ======
    function fitAll(){
      const b = L.latLngBounds([]);
      if(officialRouteGroup.getLayers().length) b.extend(officialRouteGroup.getBounds());
      if(plannedLayer) b.extend(plannedLayer.getBounds());
      if(destMarkers.length) b.extend(L.featureGroup(destMarkers).getBounds());
      if(legHighlight) b.extend(legHighlight.getBounds());
      if(b.isValid()) map.fitBounds(b, {padding:[20,20]});
    }

    // ====== 順路カード更新 ======
    function renderRouteCard(){
      const rec = window.DN_destLabelCurrent?.();
      $('#rcAddr').textContent  = rec?.address || rec?.住所 || '';
      $('#rcTitle').textContent = rec?.name || rec?.氏名 || rec?.お名前 || '';
      $('#rcNote').textContent  = rec?.note || rec?.備考 || '';
    }

    // ====== CSV順の移動（前後） ======
    let lastRec = null;
    function stepCSV(delta){
      const curr = window.DN_destLabelCurrent?.() || null;
      if (curr) lastRec = curr;

      const rec = window.DN_destLabelMove ? window.DN_destLabelMove(delta) : null;
      if (rec && Number.isFinite(rec.lat) && Number.isFinite(rec.lng)) map.panTo([rec.lat, rec.lng]);
      refreshCounterAndHighlight(rec, lastRec);
      renderRouteCard();
      autoZoomReset(/*restore=*/true);  // ★ 追加：目的地を切り替えたら倍率を一度戻す
    }

    function refreshCounterAndHighlight(nowRec = window.DN_destLabelCurrent?.(), prevRec = lastRec){
      const idx   = window.DN_destLabelIndex?.() ?? 0;
      const total = window.DN_destLabelCount?.() ?? csvRows.length;
      $('#counter').textContent = `#${total ? idx+1 : 0} / ${total}`;
      $('#btnPrev').disabled = (idx <= 0);
      $('#btnNext').disabled = (idx >= total-1);
      updateLegHighlight(prevRec, nowRec);
      window.DN_setTurnLeg && window.DN_setTurnLeg(prevRec, nowRec); // ターン案内へ
    }

    // ====== 区間ハイライト ======
    function nearestIndexOnRoute(pt){
      if (!officialRouteFlat.length) return 0;
      let best = 0, bestD = Infinity;
      for (let i=0;i<officialRouteFlat.length;i++){
        const d = distanceMeters(pt, officialRouteFlat[i]);
        if (d < bestD){ bestD = d; best = i; }
      }
      return best;
    }
    function updateLegHighlight(prevRec, nowRec){
      if (legHighlight) { map.removeLayer(legHighlight); legHighlight=null; }
      if (!nowRec || !Number.isFinite(nowRec.lat) || !Number.isFinite(nowRec.lng)) return;

      let A=null, B=[nowRec.lat, nowRec.lng];
      if (prevRec && Number.isFinite(prevRec.lat) && Number.isFinite(prevRec.lng)) A=[prevRec.lat, prevRec.lng]; else A=B;

      if (!officialRouteFlat.length) {
        if (A && B) legHighlight = L.polyline([A,B], {color:'#ff2970', weight:7}).addTo(map);
        return;
      }
      const s = nearestIndexOnRoute(A);
      const e = nearestIndexOnRoute(B);
      const seg = (s<=e) ? officialRouteFlat.slice(s, e+1) : officialRouteFlat.slice(e, s+1).reverse();
      if (seg.length >= 2) legHighlight = L.polyline(seg, { color:'#ff2970', weight:7, opacity:0.9 }).addTo(map);
    }

    // ====== GPS ======
    let watchId = null, __arriveSinceTs = 0, __arriveCooldownUntil = 0;
    function startGPS(){
      if(!('geolocation' in navigator)){ setStatus('この端末はGPS非対応'); return; }
      $('#btnGPS').disabled = true; $('#btnStop').disabled = false; setStatus('測位中…');
      liveTrack.setLatLngs([]);

      watchId = navigator.geolocation.watchPosition(onPos, onErr, {
        enableHighAccuracy:true, maximumAge:0, timeout:15000
      });
    }
    function stopGPS(){
      if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
      $('#btnGPS').disabled = false; $('#btnStop').disabled = true; setStatus('停止しました');
    }
    function onPos(pos){
      const { latitude:lat, longitude:lng, accuracy, heading:h } = pos.coords;
      const curr = [lat, lng];

      // 自位置
      if (!userMarker) {
        userMarker = L.marker(curr, { icon:userIcon, rotationAngle:0, rotationOrigin:'center' }).addTo(map);
        userAccCircle = L.circle(curr, { radius: accuracy||0, color:'#2b8', weight:1, fillOpacity:0.07 }).addTo(map);
      } else {
        userMarker.setLatLng(curr);
        userAccCircle?.setLatLng(curr).setRadius(accuracy||0);
      }

      // 進行方向
      let hdg = Number.isFinite(h) ? h : (lastLatLng ? bearing(lastLatLng, curr) : lastHeading||0);
      if (rotateToHeading && userMarker.setRotationAngle) userMarker.setRotationAngle(hdg);
      lastHeading = hdg; lastLatLng = curr;

      if (followMode) map.setView(curr, map.getZoom(), {animate:false});
      liveTrack.addLatLng(curr);

      // 到着判定（距離×精度・滞在）
      const rec = window.DN_destLabelCurrent?.();
      if (rec && Number.isFinite(rec.lat) && Number.isFinite(rec.lng)) {
        const d = distanceMeters(curr, [rec.lat, rec.lng]);
        autoZoomMaybe(d, curr);  // ★ 追加：残距離に応じて自動ズーム制御
        const acc = accuracy ?? 30;
        const userR = parseFloat($('#radius').value) || 50;
        const autoR = Math.round(acc * 0.6 + 3);
        const effR  = Math.max(MIN_RADIUS, Math.min(userR, autoR));

        const now = performance.now();
        const speedKmh = (pos.coords.speed != null && isFinite(pos.coords.speed)) ? pos.coords.speed * 3.6 : null;
        const isSlow = (speedKmh == null) ? true : (speedKmh <= SPEED_SLOW_KMH);
        const cooldownOK = now >= __arriveCooldownUntil;

        if (d <= effR) { if (!__arriveSinceTs) __arriveSinceTs = now; } else { __arriveSinceTs = 0; }
        const hasDwelled = __arriveSinceTs && ((now - __arriveSinceTs) >= ARRIVE_DWELL_MS);
        setStatus(`精度±${Math.round(accuracy||0)}m / 目的地まで ${Math.round(d)}m / 判定${effR}m`);

        if (d <= effR && hasDwelled && isSlow && cooldownOK) {
          ping(); showArrive(rec);
          __arriveSinceTs = 0; __arriveCooldownUntil = now + ARRIVE_COOLDOWN_MS;
          // 自動前進はテスト中なのでオフ（必要なら stepCSV(+1)）
        }
      }
    }
    function onErr(err){ setStatus('GPSエラー: ' + err.message); }

    // ====== サウンド/バイブ/QR ======
    let audioCtx = null;
    function ping(){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator(), g = audioCtx.createGain();
        o.frequency.value = 880; g.gain.value = 0.0001;
        o.connect(g).connect(audioCtx.destination);
        o.start(); g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.25);
        o.stop(audioCtx.currentTime+0.26);
      }catch(e){}
      if(navigator.vibrate) navigator.vibrate([200,100,200]);
    }
    function showQR(){
      const url = location.origin + location.pathname + location.search;
      const canvas = document.getElementById('qrCanvas');
      QRCode.toCanvas(canvas, url, { width: 260, margin: 1 }, (err)=>{ if(err) console.error(err); });
      document.getElementById('qrUrl').textContent = url;
      document.getElementById('qrModal').style.display = 'flex';
    }

    // ====== 距離・方位 ======
    function distanceMeters(a,b){
      const toR = x=>x*Math.PI/180, R=6371000;
      const dLat=toR(b[0]-a[0]), dLng=toR(b[1]-a[1]);
      const s1=Math.sin(dLat/2)**2 + Math.cos(toR(a[0]))*Math.cos(toR(b[0]))*Math.sin(dLng/2)**2;
      return 2*R*Math.asin(Math.sqrt(s1));
    }
    function bearing(a,b){
      const toR=d=>d*Math.PI/180, toD=r=>r*180/Math.PI;
      const φ1=toR(a[0]), φ2=toR(b[0]), Δλ=toR(b[1]-a[1]);
      const y=Math.sin(Δλ)*Math.cos(φ2);
      const x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      return (toD(Math.atan2(y,x))+360)%360;
    }

    // ====== 到着ポップアップ ======
    function showArrive(d){
      const html = `<div><strong>到着:</strong> ${d.name||''}<br>
        緯度:${Number.isFinite(d.lat)?d.lat.toFixed(6):'-'} / 経度:${Number.isFinite(d.lng)?d.lng.toFixed(6):'-'}</div>`;
      if (Number.isFinite(d.lat) && Number.isFinite(d.lng)){
        L.popup().setLatLng([d.lat,d.lng]).setContent(html).openOn(map);
      }
    }

    // ====== 地図オーバレイ（turns.js から呼ばれる想定。無くても安全） ======
    window.DN_setMapOverlay = function(dir, bend, next, dist){
      const host = document.getElementById('turnOverlay');
      const cv   = document.getElementById('turnOverlayCv');
      if (!host || !cv) return;

      const SHOW_TH = 80; // m
      const show = (next && next.type!=='arrive' && dist <= SHOW_TH);
      host.classList.toggle('show', show);
      const ctx = cv.getContext('2d'); ctx.clearRect(0,0,cv.width,cv.height);
      if (!show) return;

      const W=cv.width, H=cv.height;
      const bendDeg = Math.max(25, Math.min(180, Math.round(bend || 90)));
      const sign = (dir==='left' || dir==='slight_left') ? -1 : +1;

      const S = Math.min(W,H);
      const body = Math.round(S*0.12), outline = Math.round(body*1.28);
      const preLen = Math.round(S*0.20), postLen = Math.round(S*0.22), curveLen = Math.round(S*0.30);
      const x0 = W*0.32, y0 = H*0.78;
      const P1 = {x:x0, y:y0-preLen};
      const rad = bendDeg*Math.PI/180, dirX=Math.sin(rad)*sign, dirY=-Math.cos(rad);
      const kLen = curveLen*(90/bendDeg);
      const P2={x:P1.x+dirX*kLen, y:P1.y+dirY*kLen};
      const cGain=0.55*(bendDeg/90), C1={x:P1.x, y:P1.y-cGain*curveLen}, C2={x:P2.x-dirX*cGain*curveLen, y:P2.y-dirY*cGain*curveLen};
      const P3={x:P2.x+dirX*postLen, y:P2.y+dirY*postLen};

      const head=(w)=>{ const nx=-dirY, ny=dirX, tip=P3, base={x:P3.x-dirX*(w*1.65), y:P3.y-dirY*(w*1.65)},
        L={x:base.x+nx*w, y:base.y+ny*w}, R={x:base.x-nx*w, y:base.y-ny*w};
        ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath(); };
      const stroke=(w,color)=>{ ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(P1.x,P1.y);
        ctx.bezierCurveTo(C1.x,C1.y,C2.x,C2.y,P2.x,P2.y); ctx.lineTo(P3.x,P3.y);
        ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=color; ctx.lineWidth=w; ctx.stroke();
        ctx.beginPath(); head(w*0.62); ctx.fillStyle=color; ctx.fill(); };

      stroke(outline,'#0b3a5a'); stroke(body,'#12b24a');

      // 白ヘッド（進行方向）
      const iw = Math.max(14, Math.round(body*0.85));
      const nx=-dirY, ny=dirX;
      const tip=P3, base={x:P3.x-dirX*(iw*1.25), y:P3.y-dirY*(iw*1.25)},
            L={x:base.x+nx*(iw*0.70), y:base.y+ny*(iw*0.70)},
            R={x:base.x-nx*(iw*0.70), y:base.y-ny*(iw*0.70)};
      ctx.beginPath(); ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fill();
      ctx.beginPath(); ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath();
      ctx.fillStyle='#fff'; ctx.fill();
    };

  }); // initApp
  </script>

  <!-- Assist（destLabel / rideHud / turns などを起動） -->
  <script type="module" src="./src/assist/initAssist.js"></script>
</body>
</html>







