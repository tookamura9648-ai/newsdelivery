<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>DeliNavi</title>

  <!-- 軽量favicon -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E🗺️%3C/text%3E%3C/svg%3E">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- 回転マーカー -->
  <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <!-- CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- QR -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>

  <style>
    html,body{height:100%;margin:0}
    body{background:#000;overscroll-behavior:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",Meiryo,sans-serif}
    #map{position:fixed;inset:0}

    /* 右上の操作パネル */
    .panel{
      position:absolute;z-index:1000;left:10px;top:10px;background:#fff;
      padding:10px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.15)
    }
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:6px}
    .btn{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f6f6f6;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .badge{background:#111;color:#fff;border-radius:10px;padding:3px 8px;font-weight:700}
    .small{font-size:12px;color:#666}

    /* ===== 下部の順路カード（黒） ===== */
    .route-card{
      position:fixed; left:8px; right:8px; bottom:8px; z-index:9500;
      background: rgba(0,0,0,.90);  /* フォールバック */
      color:#fff; border-radius:14px; padding:10px 12px; box-shadow:0 10px 24px rgba(0,0,0,.35);
      display:flex !important; align-items:center; gap:10px;
      min-height:92px;  /* 矢印ラベルと同じ高さに固定 */
    }
    @supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {
      .route-card{
        background: rgba(0,0,0,.82);
        -webkit-backdrop-filter: saturate(1.2) blur(2px);
        backdrop-filter: saturate(1.2) blur(2px);
      }
    }
    /*.route-card .meta{flex:1 1 auto; min-width:0; display:flex; flex-direction:column; justify-content:center; min-height:inherit}
    .route-card .title{font-weight:800; font-size:20px; line-height:1.2; letter-spacing:.06em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .route-card .addr{opacity:.95; font-size:13px; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .route-card .note{opacity:.85; font-size:12px; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top:2px} */
    .route-card .menu-btn{flex:0 0 auto; padding:8px 12px; border-radius:9px; border:1px solid rgba(255,255,255,.25); background:#07445f; color:#fff; font-weight:700; cursor:pointer}

    /* 地図上の大矢印オーバレイ */
    .turn-overlay{ position:fixed; inset:0; z-index:9400; pointer-events:none; display:none }
    .turn-overlay.show{ display:block }
    .turn-overlay canvas{ position:absolute; left:50%; top:50%; transform:translate(-50%,-60%); width:min(64vw,64vh); height:auto }

    /* Leafletの番号ツールチップは非表示（混雑防止） */
    .leaflet-tooltip{ display:none !important }

    /* HUDのキャンバス反転オプション（必要なら使う） */
    #dn-hud-cv { transition: transform .15s ease; }
    body.hud-flip #dn-hud-cv { transform: rotate(180deg); }

    /* 白い小カードは常に消す（turns.jsが出しても隠す） */
    #dn-turn-card, .dn-turn-card{ display:none !important; visibility:hidden !important; pointer-events:none !important; }
  </style>
</head>
<body>
  <!-- 地図 -->
  <div id="map" aria-label="map"></div>

  <!-- 地図上の矢印オーバレイ -->
  <div id="turnOverlay" class="turn-overlay" aria-hidden="true">
    <canvas id="turnOverlayCv" width="512" height="512"></canvas>
  </div>

  <!-- 下の順路カード（氏名・住所・備考＋Menu） -->
  <div id="routeCard" class="route-card" role="region" aria-label="次の配達先">
    <div class="meta">
      <div id="rcAddr"  class="addr">—</div>
      <div id="rcTitle" class="title">—</div>
      <div id="rcNote"  class="note">—</div>
    </div>
    <button id="rcMenu" class="menu-btn">Menu</button>
  </div>

  <!-- 右上の操作パネル -->
  <div class="panel">
    <div class="row">
      <span class="badge" id="counter">#0 / 0</span>
      <button class="btn" id="btnFit">全体表示</button>
      <button class="btn" id="btnPrev" disabled>◀ 前</button>
      <button class="btn" id="btnNext" disabled>次 ▶</button>
      <button class="btn" id="btnHUD">HUD</button>
      <button class="btn" id="btnQR">QR共有</button>
    </div>
    <div class="row">
      <button class="btn" id="btnGPS">GPS開始</button>
      <button class="btn" id="btnStop" disabled>停止</button>
      <label class="small">到着半径 <input type="number" id="radius" value="50" style="width:4.5em"> m</label>
    </div>
    <div class="row">
      <label class="small"><input type="checkbox" id="chkFollow" checked> 中央固定（追従）</label>
      <label class="small"><input type="checkbox" id="chkHeading" checked> 矢印＝進行方向</label>
    </div>
    <div class="small" id="status">初期化中…</div>
  </div>

  <!-- QRモーダル -->
  <div id="qrModal" style="display:none;position:fixed;inset:0;z-index:2000;background:rgba(0,0,0,.5);align-items:center;justify-content:center">
    <div style="background:#fff;padding:16px 18px;border-radius:12px;text-align:center">
      <canvas id="qrCanvas" width="260" height="260"></canvas><br>
      <div style="margin-top:8px;font-size:12px" id="qrUrl"></div>
      <button class="btn" id="qrClose" style="margin-top:10px">閉じる</button>
    </div>
  </div>

  <!-- アプリ本体 -->
  <script>
  (function whenReady(fn){
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, {once:true});
    else fn();
  })(function initApp(){

    // ====== 設定 ======
    const CSV_URL = './assets/data/points.csv'; // name,address,note,lat,lng（日本語列名も可）
    const OFFICIAL_ROUTE_URL = './assets/routes/official-route.geojson';
    const SHOW_PLANNED_LINE = false;

    // 到着判定・自動ズーム
    const MIN_RADIUS = 8, ARRIVE_DWELL_MS = 2000, SPEED_SLOW_KMH = 8, ARRIVE_COOLDOWN_MS = 10000;
    const APPROACH_ZOOM_IN_M = 90, APPROACH_ZOOM_OUT_M = 140, APPROACH_ZOOM_LEVEL = 18, APPROACH_FLY_MS = 800;

    // HUDは手動のみ
    const HUD_MANUAL_ONLY = true;

    // ====== 地図 ======
    const map = L.map('map', {zoomControl:true, preferCanvas:true}).setView([35.0,135.87], 13);
    window.__DN_map = map;
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      {maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

    // アクセシビリティ名
    const zc = map.zoomControl;
    if (zc && zc._zoomInButton) { zc._zoomInButton.setAttribute('title','拡大'); zc._zoomInButton.setAttribute('aria-label','拡大'); }
    if (zc && zc._zoomOutButton){ zc._zoomOutButton.setAttribute('title','縮小'); zc._zoomOutButton.setAttribute('aria-label','縮小'); }

    // ====== 公式ルート ======
    const officialRouteGroup = L.featureGroup().addTo(map);
    let officialSegments = [], officialRouteFlat = [], legHighlight = null;

    // ====== CSV目的地 ======
    let csvRows = [];
    let destMarkers = [];
    let plannedLayer = null;

    // ====== 実走ログ ======
    const liveTrack = L.polyline([], {color:'#222', weight:3}).addTo(map);

    // ====== 自位置マーカー（進行方向回転） ======
    const userIcon = L.icon({
      iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
           <defs><filter id="s"><feDropShadow dx="0" dy="1" stdDeviation="1" flood-opacity="0.4"/></filter></defs>
           <g filter="url(#s)">
             <circle cx="32" cy="32" r="9" fill="#fff"/>
             <polygon points="32,6 44,34 32,28 20,34" fill="#007aff"/>
           </g>
         </svg>`),
      iconSize:[44,44], iconAnchor:[22,22]
    });
    let userMarker = null, userAccCircle = null;
    let followMode = true, rotateToHeading = true;
    let lastLatLng = null, lastHeading = 0;

    // ====== UIヘルパ ======
    const $ = s => document.querySelector(s);
    const setStatus = t => $('#status').textContent = t;

    // ====== 状態（到着・自動ズーム・コンパス） ======
    let __arriveSinceTs = 0, __arriveCooldownUntil = 0;
    let __autoZoomed = false, __autoZoomPrevZoom = null, __autoZoomTargetIdx = null;
    let __compassHeading = null, __headingLPF = null;

    // ====== イベント配線 ======
    $('#btnFit').addEventListener('click', fitAll);
    $('#btnPrev').addEventListener('click', e=>{ e.preventDefault(); stepCSV(-1); });
    $('#btnNext').addEventListener('click', e=>{ e.preventDefault(); stepCSV(+1); });
    $('#btnQR').addEventListener('click', showQR);
    $('#qrClose').addEventListener('click', ()=>{ $('#qrModal').style.display='none'; });

    $('#btnGPS').addEventListener('click', startGPS);
    $('#btnStop').addEventListener('click', stopGPS);
    $('#btnHUD').addEventListener('click', ()=> setHUD(!document.body.classList.contains('hud')) );

    $('#chkFollow').addEventListener('change', e=>{ followMode=e.target.checked; if(followMode && lastLatLng) map.setView(lastLatLng, map.getZoom(), {animate:false}); });
    $('#chkHeading').addEventListener('change', e=>{ rotateToHeading=e.target.checked; if(userMarker?.setRotationAngle) userMarker.setRotationAngle(rotateToHeading?lastHeading:0); });

    $('#rcMenu').addEventListener('click', ()=>{
      const p = document.querySelector('.panel'); if(!p) return;
      p.style.display = (p.style.display==='none') ? 'block' : 'none';
    });

    // 起動時にHUD/反転オプション復元
    if (localStorage.getItem('dnHudOn')==='1') document.body.classList.add('hud');
    if (localStorage.getItem('dnHudFlip')==='1') document.body.classList.add('hud-flip');
    if (localStorage.getItem('dnTurnInvert')==='1') document.body.classList.add('turn-invert');
    window.DN_requestHUD = (want)=>{ if (!HUD_MANUAL_ONLY) setHUD(!!want); }; // 自動要求は無視

    // ====== 初期ロード ======
    Promise.all([loadOfficialRoute(), loadCSV()])
      .then(()=>{ setStatus('準備OK。GPS開始でスタート'); fitAll(); })
      .catch(err=>{ console.error(err); setStatus('読み込みエラー: '+err.message); });

    // ====== CSV 読み込み ======
    async function loadCSV(){
      const res = await fetch(CSV_URL, {cache:'no-store'});
      if(!res.ok) throw new Error('points.csv not found');
      const text = await res.text();
      const parsed = Papa.parse(text, {header:true, skipEmptyLines:true});

      csvRows = parsed.data.map(r=>({
        name: (r.name ?? r.氏名 ?? r.お名前 ?? r.label ?? '').trim(),
        address: (r.address ?? r.住所 ?? r.所在地 ?? '').trim(),
        note: (r.note ?? r.備考 ?? r.メモ ?? r.区分 ?? '').trim(),
        lat: parseFloat(r.lat ?? r.latitude ?? r.緯度),
        lng: parseFloat(r.lng ?? r.longitude ?? r.経度)
      }));

      // マーカー作成（座標がある行のみ）
      destMarkers.forEach(m=>map.removeLayer(m)); destMarkers=[];
      if (plannedLayer){ map.removeLayer(plannedLayer); plannedLayer=null; }

      csvRows.forEach((d)=>{
        if (Number.isFinite(d.lat) && Number.isFinite(d.lng)) {
          const m = L.marker([d.lat,d.lng]).addTo(map);
          destMarkers.push(m);
        }
      });

      // Assistへ登録 → 起動直後は「次だけ」
      window.DN_registerDestinationMarkers && window.DN_registerDestinationMarkers(destMarkers, map);
      window.DN_setMarkerMode && window.DN_setMarkerMode('next');

      const rad = $('#radius'); if (rad){ rad.min=MIN_RADIUS; rad.step=1; if ((parseFloat(rad.value)||0) < MIN_RADIUS) rad.value = MIN_RADIUS; }

      if (SHOW_PLANNED_LINE) {
        const line = csvRows.filter(d=>Number.isFinite(d.lat)&&Number.isFinite(d.lng)).map(d=>[d.lat,d.lng]);
        plannedLayer = L.polyline(line, { color:'#1e6bff', weight:3, dashArray:'6 6' }).addTo(map);
      }

      setTimeout(()=>{ refreshCounterAndHighlight(); renderRouteCard(); }, 0);
    }

    // ====== 公式ルート ======
    async function loadOfficialRoute(){
      const res = await fetch(OFFICIAL_ROUTE_URL + '?v=' + Date.now(), {cache:'no-store'});
      if(!res.ok) throw new Error('official-route.geojson not found');
      const gj = await res.json();

      officialRouteGroup.clearLayers();
      officialSegments = []; officialRouteFlat = [];

      const feats = (gj.type==='FeatureCollection') ? (gj.features||[]) : [gj];
      feats.forEach(ft=>{
        if(!ft?.geometry) return;
        const color = (ft.properties?.leg==='back') ? '#ff8c00' : '#00a7a7';
        const segs = [];
        if(ft.geometry.type==='LineString'){
          if(ft.geometry.coordinates?.length>=2) segs.push(ft.geometry.coordinates);
        }else if(ft.geometry.type==='MultiLineString'){
          (ft.geometry.coordinates||[]).forEach(c=>{ if(c?.length>=2) segs.push(c); });
        }
        segs.forEach(coords=>{
          const latlngs = coords.map(([lng,lat])=>[lat,lng]);
          L.polyline(latlngs, {color, weight:5, opacity:.9}).addTo(officialRouteGroup);
          officialSegments.push(latlngs);
          officialRouteFlat.push(...latlngs);
        });
      });
    }

    // ====== 表示範囲 ======
    function fitAll(){
      const b = L.latLngBounds([]);
      if(officialRouteGroup.getLayers().length) b.extend(officialRouteGroup.getBounds());
      if(plannedLayer) b.extend(plannedLayer.getBounds());
      if(destMarkers.length) b.extend(L.featureGroup(destMarkers).getBounds());
      if(legHighlight) b.extend(legHighlight.getBounds());
      if(b.isValid()) map.fitBounds(b, {padding:[20,20]});
    }

    // ====== 順路カード更新 ======
    function renderRouteCard(){
      const rec = window.DN_destLabelCurrent?.();
      $('#rcAddr').textContent  = rec?.address || rec?.住所 || '';
      $('#rcTitle').textContent = rec?.name || rec?.氏名 || rec?.お名前 || '';
      $('#rcNote').textContent  = rec?.note || rec?.備考 || '';
    }

    // ====== CSV順 前後移動 ======
    let lastRec = null;
    function stepCSV(delta){
      const curr = window.DN_destLabelCurrent?.() || null;
      if (curr) lastRec = curr;

      const rec = window.DN_destLabelMove ? window.DN_destLabelMove(delta) : null;
      if (rec && Number.isFinite(rec.lat) && Number.isFinite(rec.lng)) map.panTo([rec.lat, rec.lng]);
      refreshCounterAndHighlight(rec, lastRec);
      renderRouteCard();
      autoZoomReset(true); // 切替時は倍率を戻す
    }

    function refreshCounterAndHighlight(nowRec = window.DN_destLabelCurrent?.(), prevRec = lastRec){
      const idx   = window.DN_destLabelIndex?.() ?? 0;
      const total = window.DN_destLabelCount?.() ?? csvRows.length;
      $('#counter').textContent = `#${total ? idx+1 : 0} / ${total}`;
      $('#btnPrev').disabled = (idx <= 0);
      $('#btnNext').disabled = (idx >= total-1);
      updateLegHighlight(prevRec, nowRec);
      window.DN_setTurnLeg && window.DN_setTurnLeg(prevRec, nowRec); // ターン案内へ
    }

    // ====== 区間ハイライト ======
    function nearestIndexOnRoute(pt){
      if (!officialRouteFlat.length) return 0;
      let best = 0, bestD = Infinity;
      for (let i=0;i<officialRouteFlat.length;i++){
        const d = distanceMeters(pt, officialRouteFlat[i]);
        if (d < bestD){ bestD = d; best = i; }
      }
      return best;
    }
    function updateLegHighlight(prevRec, nowRec){
      if (legHighlight) { map.removeLayer(legHighlight); legHighlight=null; }
      if (!nowRec || !Number.isFinite(nowRec.lat) || !Number.isFinite(nowRec.lng)) return;

      let A=null, B=[nowRec.lat, nowRec.lng];
      if (prevRec && Number.isFinite(prevRec.lat) && Number.isFinite(prevRec.lng)) A=[prevRec.lat, prevRec.lng]; else A=B;

      if (!officialRouteFlat.length) {
        if (A && B) legHighlight = L.polyline([A,B], {color:'#ff2970', weight:7}).addTo(map);
        return;
      }
      const s = nearestIndexOnRoute(A);
      const e = nearestIndexOnRoute(B);
      const seg = (s<=e) ? officialRouteFlat.slice(s, e+1) : officialRouteFlat.slice(e, s+1).reverse();
      if (seg.length >= 2) legHighlight = L.polyline(seg, { color:'#ff2970', weight:7, opacity:0.9 }).addTo(map);
    }

    // ====== GPS ======
    let watchId = null;
    function startGPS(){
      if(!('geolocation' in navigator)){ setStatus('この端末はGPS非対応'); return; }
      $('#btnGPS').disabled = true; $('#btnStop').disabled = false; setStatus('測位中…');
      liveTrack.setLatLngs([]);

      enableCompass(); // コンパス許可（iOSはユーザー操作直後でOK）

      watchId = navigator.geolocation.watchPosition(onPos, onErr, {
        enableHighAccuracy:true, maximumAge:0, timeout:15000
      });
    }
    function stopGPS(){
      if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
      $('#btnGPS').disabled = false; $('#btnStop').disabled = true; setStatus('停止しました');
    }
    function onPos(pos){
      const { latitude:lat, longitude:lng, accuracy, heading:h } = pos.coords;
      const curr = [lat, lng];

      // 自位置
      if (!userMarker) {
        userMarker = L.marker(curr, { icon:userIcon, rotationAngle:0, rotationOrigin:'center center' }).addTo(map);
        userAccCircle = L.circle(curr, { radius: accuracy||0, color:'#2b8', weight:1, fillOpacity:0.07 }).addTo(map);
      } else {
        userMarker.setLatLng(curr);
        userAccCircle?.setLatLng(curr).setRadius(accuracy||0);
      }

      // 進行方向（GPS course / コンパス / 直前ベクトル）
      let hdg = getHeadingFromSensors(pos, lastLatLng, curr);
      if (rotateToHeading && userMarker.setRotationAngle) userMarker.setRotationAngle(hdg);
      lastHeading = hdg; lastLatLng = curr;

      if (followMode) map.setView(curr, map.getZoom(), {animate:false});
      liveTrack.addLatLng(curr);

      // 到着判定・自動ズーム
      const rec = window.DN_destLabelCurrent?.();
      if (rec && Number.isFinite(rec.lat) && Number.isFinite(rec.lng)) {
        const d = distanceMeters(curr, [rec.lat, rec.lng]);
        autoZoomMaybe(d, curr); // ← 近づいたらズーム

        const acc = accuracy ?? 30;
        const userR = parseFloat($('#radius').value) || 50;
        const autoR = Math.round(acc * 0.6 + 3);
        const effR  = Math.max(MIN_RADIUS, Math.min(userR, autoR));

        const now = performance.now();
        const speedKmh = (pos.coords.speed != null && isFinite(pos.coords.speed)) ? pos.coords.speed * 3.6 : null;
        const isSlow = (speedKmh == null) ? true : (speedKmh <= SPEED_SLOW_KMH);
        const cooldownOK = now >= __arriveCooldownUntil;

        if (d <= effR) { if (!__arriveSinceTs) __arriveSinceTs = now; } else { __arriveSinceTs = 0; }
        const hasDwelled = __arriveSinceTs && ((now - __arriveSinceTs) >= ARRIVE_DWELL_MS);
        setStatus(`精度±${Math.round(accuracy||0)}m / 目的地まで ${Math.round(d)}m / 判定${effR}m`);

        if (d <= effR && hasDwelled && isSlow && cooldownOK) {
          ping(); showArrive(rec);
          __arriveSinceTs = 0; __arriveCooldownUntil = now + ARRIVE_COOLDOWN_MS;
          autoZoomReset(true); // 到着時に倍率を戻す
        }
      }
    }
    function onErr(err){ setStatus('GPSエラー: ' + err.message); }

    // ====== コンパス ======
    function enableCompass(){
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(res=>{
          if (res === 'granted') {
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
          }
        }).catch(()=>{});
      } else if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientationabsolute' in window ? 'deviceorientationabsolute' : 'deviceorientation', onDeviceOrientation, true);
      }
    }
    function onDeviceOrientation(e){
      const alpha = (typeof e.alpha === 'number') ? e.alpha : null;
      if (alpha == null) return;
      const heading = (360 - alpha) % 360; // 北=0°
      __compassHeading = heading;
    }
    function smoothHeading(deg){
      if (__headingLPF == null) { __headingLPF = deg; return deg; }
      let diff = ((deg - __headingLPF + 540) % 360) - 180;
      __headingLPF = (__headingLPF + diff * 0.25 + 360) % 360;
      return __headingLPF;
    }
    function getHeadingFromSensors(pos, lastLL, currLL){
      const h = (pos.coords && Number.isFinite(pos.coords.heading)) ? pos.coords.heading : null;
      const speed = (pos.coords.speed != null && isFinite(pos.coords.speed)) ? pos.coords.speed : 0; // m/s
      const slow  = speed < 1.5;
      let cand = null;
      if (!slow && h != null) cand = h;
      else if (__compassHeading != null) cand = __compassHeading;
      else if (lastLL) cand = bearing(lastLL, currLL);
      else cand = lastHeading || 0;
      return smoothHeading((cand + 360) % 360);
    }

    // ====== 到着ポップアップ ======
    function showArrive(d){
      const html = `<div><strong>到着:</strong> ${d.name||''}<br>
        緯度:${Number.isFinite(d.lat)?d.lat.toFixed(6):'-'} / 経度:${Number.isFinite(d.lng)?d.lng.toFixed(6):'-'}</div>`;
      if (Number.isFinite(d.lat) && Number.isFinite(d.lng)){
        L.popup().setLatLng([d.lat,d.lng]).setContent(html).openOn(map);
      }
    }

    // ====== 自動ズーム ======
    function autoZoomMaybe(distM, hereLatLng){
      const idx = window.DN_destLabelIndex?.();
      if (idx == null) return;
      if (__autoZoomTargetIdx !== idx) { autoZoomReset(false); __autoZoomTargetIdx = idx; }
      if (!__autoZoomed && distM <= APPROACH_ZOOM_IN_M){
        __autoZoomPrevZoom = map.getZoom(); __autoZoomed = true;
        map.flyTo(hereLatLng, APPROACH_ZOOM_LEVEL, { animate:true, duration: APPROACH_FLY_MS/1000 });
      }
      if (__autoZoomed && distM >= APPROACH_ZOOM_OUT_M) autoZoomRestore();
    }
    function autoZoomRestore(){
      if (!__autoZoomed) return;
      const z = (__autoZoomPrevZoom ?? 15);
      __autoZoomed = false; __autoZoomPrevZoom = null;
      map.flyTo(map.getCenter(), z, { animate:true, duration: APPROACH_FLY_MS/1000 });
    }
    function autoZoomReset(restore=true){ if (restore) autoZoomRestore(); __autoZoomed=false; __autoZoomPrevZoom=null; }

    // ====== HUD手動切替 ======
    function setHUD(on){
      document.body.classList.toggle('hud', !!on);
      localStorage.setItem('dnHudOn', on ? '1' : '0');
    }

    // ====== サウンド/QR/距離 ======
    let audioCtx = null;
    function ping(){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator(), g = audioCtx.createGain();
        o.frequency.value = 880; g.gain.value = 0.0001;
        o.connect(g).connect(audioCtx.destination);
        o.start(); g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.25);
        o.stop(audioCtx.currentTime+0.26);
      }catch(e){}
      if(navigator.vibrate) navigator.vibrate([200,100,200]);
    }
    function showQR(){
      const url = location.origin + location.pathname + location.search;
      const canvas = document.getElementById('qrCanvas');
      QRCode.toCanvas(canvas, url, { width: 260, margin: 1 }, (err)=>{ if(err) console.error(err); });
      document.getElementById('qrUrl').textContent = url;
      document.getElementById('qrModal').style.display = 'flex';
    }
    function distanceMeters(a,b){
      const toR = x=>x*Math.PI/180, R=6371000;
      const dLat=toR(b[0]-a[0]), dLng=toR(b[1]-a[1]);
      const s1=Math.sin(dLat/2)**2 + Math.cos(toR(a[0]))*Math.cos(toR(b[0]))*Math.sin(dLng/2)**2;
      return 2*R*Math.asin(Math.sqrt(s1));
    }
    function bearing(a,b){
      const toR=d=>d*Math.PI/180, toD=r=>r*180/Math.PI;
      const φ1=toR(a[0]), φ2=toR(b[0]), Δλ=toR(b[1]-a[1]);
      const y=Math.sin(Δλ)*Math.cos(φ2);
      const x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      return (toD(Math.atan2(y,x))+360)%360;
    }

    // ====== 地図オーバレイ（turns.js から呼ばれる想定）=====
    window.DN_setMapOverlay = function(dir, bend, next, dist){
      const host = document.getElementById('turnOverlay');
      const cv   = document.getElementById('turnOverlayCv');
      if (!host || !cv) return;

      const SHOW_TH = 80; // m
      const show = (next && next.type!=='arrive' && dist <= SHOW_TH);
      host.classList.toggle('show', show);
      const ctx = cv.getContext('2d'); ctx.clearRect(0,0,cv.width,cv.height);
      if (!show) return;

      const W=cv.width, H=cv.height;
      const bendDeg = Math.max(25, Math.min(180, Math.round(bend || 90)));
      const sign = (dir==='left' || dir==='slight_left') ? -1 : +1;

      const S = Math.min(W,H);
      const body = Math.round(S*0.12), outline = Math.round(body*1.28);
      const preLen = Math.round(S*0.20), postLen = Math.round(S*0.22), curveLen = Math.round(S*0.30);
      const x0 = W*0.32, y0 = H*0.78;
      const P1 = {x:x0, y:y0-preLen};
      const rad = bendDeg*Math.PI/180, dirX=Math.sin(rad)*sign, dirY=-Math.cos(rad);
      const kLen = curveLen*(90/bendDeg);
      const P2={x:P1.x+dirX*kLen, y:P1.y+dirY*kLen};
      const cGain=0.55*(bendDeg/90), C1={x:P1.x, y:P1.y-cGain*curveLen}, C2={x:P2.x-dirX*cGain*curveLen, y:P2.y-dirY*cGain*curveLen};
      const P3={x:P2.x+dirX*postLen, y:P2.y+dirY*postLen};

      const head=(w)=>{ const nx=-dirY, ny=dirX, tip=P3, base={x:P3.x-dirX*(w*1.65), y:P3.y-dirY*(w*1.65)},
        L={x:base.x+nx*w, y:base.y+ny*w}, R={x:base.x-nx*w, y:base.y-ny*w};
        ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath(); };
      const stroke=(w,color)=>{ ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(P1.x,P1.y);
        ctx.bezierCurveTo(C1.x,C1.y,C2.x,C2.y,P2.x,P2.y); ctx.lineTo(P3.x,P3.y);
        ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=color; ctx.lineWidth=w; ctx.stroke();
        ctx.beginPath(); head(w*0.62); ctx.fillStyle=color; ctx.fill(); };

      stroke(outline,'#0b3a5a'); stroke(body,'#12b24a');

      // 白ヘッド（進行方向）
      const iw = Math.max(14, Math.round(body*0.85));
      const nx=-dirY, ny=dirX;
      const tip=P3, base={x:P3.x-dirX*(iw*1.25), y:P3.y-dirY*(iw*1.25)},
            L={x:base.x+nx*(iw*0.70), y:base.y+ny*(iw*0.70)},
            R={x:base.x-nx*(iw*0.70), y:base.y-ny*(iw*0.70)};
      ctx.beginPath(); ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath();
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fill();
      ctx.beginPath(); ctx.moveTo(tip.x,tip.y); ctx.lineTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.closePath();
      ctx.fillStyle='#fff'; ctx.fill();
    };

  }); // initApp
  </script>

  <!-- Assist（destLabel / turns / rideHud など） -->
  <script type="module" src="./src/assist/initAssist.js"></script>
</body>
</html>








